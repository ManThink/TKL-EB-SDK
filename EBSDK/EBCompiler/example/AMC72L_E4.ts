import { EBModel } from "@EBSDK/EBCompiler/EBModel/EBModel";
import { CalcData, CrcMode, EBBuffer, ExprCondition, LoraUpEvent, QueryEvent } from "@EBSDK/EBCompiler/all_variable";
import { Buffer } from "buffer";




export const AMC72L_E4 = (ebModel: EBModel) => {
  const APP = new EBBuffer("app", Buffer.alloc(255));
  const APP_STATUS = new EBBuffer("appsts", Buffer.alloc(32));
  const SENSOR_DATA = new EBBuffer("sensor", Buffer.alloc(128));
  const TEMPLATE = new EBBuffer("temp", Buffer.alloc(128));
  const DEVICE_STATUS = new EBBuffer("ds", Buffer.alloc(16));
  const DeviceBatteryVoltage = DEVICE_STATUS.readUint8(3);
  // 最近一次查询事件是否超时判断
  const isQueryTimeOut = APP_STATUS.readUint8(2).bitwiseAnd(2).rightShift(1);


  let heartLoraUpEvent = new LoraUpEvent("heart", {
    txPort: 61,
    txBuffer: Buffer.from([0x81,0x21,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0]),
  });

  heartLoraUpEvent.pushEBData(heartLoraUpEvent.txBuffer.copyFrom({
    buffer: APP,
    bufferOffset: 52,
    byteLength: 8
  }, 3));

  heartLoraUpEvent.pushEBData(heartLoraUpEvent.txBuffer.copyFrom({
    buffer: APP,
    bufferOffset: 61,
    byteLength: 4
  }, 11));

  heartLoraUpEvent.pushEBData(heartLoraUpEvent.txBuffer.copyFrom({
    buffer: APP,
    bufferOffset: 80,
    byteLength: 1
  }, 17));

  heartLoraUpEvent.pushEBData(heartLoraUpEvent.txBuffer.copyFrom({
    buffer: APP,
    bufferOffset: 60,
    byteLength: 1
  }, 18));

  heartLoraUpEvent.pushEBData(heartLoraUpEvent.txBuffer.copyFrom({
    buffer: APP,
    bufferOffset: 29,
    byteLength: 3
  }, 19));

  heartLoraUpEvent.pushEBData(TEMPLATE.writeUint8(APP.readUint8(28).greaterThan(176), 80));

  let upEventList:Array< LoraUpEvent> = [];
  for (let i = 1; i <= 6; i++) {
    let MeterData1LoraUp = new LoraUpEvent (`MeterData_${i}`, {
      txBuffer: Buffer.from([0x21, 0x05, i, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
      txPort: 12
    }).setPeriod(300)
    upEventList[i] = MeterData1LoraUp;
  }
 
  for (let i = 1; i <= 6; i++) {
    let Qu_Meter1 = new QueryEvent(`Qu_Meter_${i}`, {
      cmdBuffer: Buffer.from([0x0 + i, 0x03, 0x00, 0x03, 0x00, 0x77, 0xC4, 0x29]),
      ackBuffer: Buffer.from([0x01, 0x03, 0xEE, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4D, 0x04, 0x58, 0x04, 0x63, 0x03, 0xE8, 0x07, 0xD0, 0x0B, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x00, 0x00, 0x00, 0x00, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0xBA, 0x11])
    }).setAckCrc({
      Mode: CrcMode.CRC16,
      Poly: "a001",
      LittleEndian: true,
      placeIndex: -2,
    }).setQueryCrc({
      Mode: CrcMode.CRC16,
    }).setPeriod(300).addAckCheckRule(1, 0x03).addAckCheckRule(2, 0xEE);
  
    Qu_Meter1.pushEBData<CalcData>(upEventList[i].txBuffer.writeUint16LE(Qu_Meter1.ackBuffer.readUint16BE(31).multiply(Qu_Meter1.ackBuffer.readUint16BE(7)), 10), {
      Repeat: 3,
      condition: ExprCondition.ONTIME
    });
    Qu_Meter1.pushEBData(upEventList[i].txBuffer.writeUint16LE(Qu_Meter1.ackBuffer.readUint16BE(37).multiply(Qu_Meter1.ackBuffer.readUint16BE(3)).divide(10), 16), {
      Repeat: 3,
      condition: ExprCondition.ONTIME
    });
    Qu_Meter1.pushEBData(upEventList[i].txBuffer.writeUint32LE(Qu_Meter1.ackBuffer.readUint32BE(221).divide(10), 22), {
      Repeat: 2,
      condition: ExprCondition.ONTIME
    });
    Qu_Meter1.pushEBData(upEventList[i].txBuffer.writeUint32LE(Qu_Meter1.ackBuffer.readUint32BE(233).divide(10), 30), {
      Repeat: 2,
      condition: ExprCondition.ONTIME
    });
    Qu_Meter1.pushEBData(upEventList[i].txBuffer.writeUint8(APP_STATUS.readUint8(2).bitwiseAnd(2).rightShift(1), 38), {
      Repeat: 2,
      condition: ExprCondition.ONTIME
    });

    Qu_Meter1.pushEBData(upEventList[i].txBuffer.copyFrom({
      bufferOffset: 25,
      byteLength: 4,
      buffer: APP
    }, 6))
  }


  return JSON.stringify(ebModel, null, 2)

}

export function run_AMC72L_E4 () {
  const ebModel = new EBModel();
  QueryEvent.ebModel = ebModel;
  LoraUpEvent.ebModel = ebModel;
  new LoraUpEvent("random", {
    txBuffer: Buffer.from([130]),
    txPort: 11
  }).setPeriod(345600000);
   new QueryEvent("random", {
    cmdBuffer: Buffer.from([]),
    ackBuffer: Buffer.from([]),
  }).setPeriod(345600000)
  console.log(JSON.parse(AMC72L_E4(ebModel)))
}
